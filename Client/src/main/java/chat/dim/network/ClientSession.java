/* license: https://mit-license.org
 *
 *  DIMP : Decentralized Instant Messaging Protocol
 *
 *                                Written in 2022 by Moky <albert.moky@gmail.com>
 *
 * ==============================================================================
 * The MIT License (MIT)
 *
 * Copyright (c) 2022 Albert Moky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * ==============================================================================
 */
package chat.dim.network;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import chat.dim.Messenger;
import chat.dim.dbi.SessionDBI;
import chat.dim.log.Log;
import chat.dim.mkm.Station;
import chat.dim.mtp.StreamArrival;
import chat.dim.net.Connection;
import chat.dim.port.Arrival;
import chat.dim.port.Porter;
import chat.dim.tcp.StreamHub;
import chat.dim.threading.BackgroundThreads;
import chat.dim.utils.ArrayUtils;

/**
 *  Session for Connection
 *  ~~~~~~~~~~~~~~~~~~~~~~
 *
 *  'key' - Session Key
 *          A random string generated by station.
 *          It will be set after handshake success.
 *
 *   'ID' - Local User ID
 *          It will be set before connecting to remote station.
 *          When it's empty, the session state would be 'Default'.
 *
 *   'active' - Session Status
 *          It will be set to True after connected to remote station.
 *          When connection broken, it will be set to False.
 *          Only send message when it's True.
 *
 *   'station' - Remote Station
 *          Station with remote IP &amp; port, its ID will be set
 *          when first handshake responded, and we can trust
 *          all messages from this ID after that.
 */
public class ClientSession extends BaseSession {

    private final Station station;
    private final StateMachine fsm;

    private String key;
    private boolean accepted;

    private Thread thread;

    public ClientSession(Station server, SessionDBI sdb) {
        super(new InetSocketAddress(server.getHost(), server.getPort()), null, sdb);
        station = server;
        fsm = new StateMachine(this);
        key = null;
        accepted = false;
        thread = null;
    }

    public Station getStation() {
        return station;
    }

    public void pause() {
        fsm.pause();
    }

    public void resume() {
        fsm.resume();
    }

    public SessionState getState() {
        SessionState state = fsm.getCurrentState();
        return  state != null ? state : fsm.getDefaultState();
    }

    @Override
    public boolean setActive(boolean flag, Date when) {
        if (!flag) {
            accepted = false;
        }
        return super.setActive(flag, when);
    }

    public boolean isAccepted() {
        return accepted;
    }
    public void setAccepted(boolean flag) {
        accepted = flag;
    }

    public boolean isReady() {
        //return isActive() && isAccepted() && getIdentifier() != null && getSessionKey() != null;
        if (!isActive() || !isAccepted()) {
            return false;
        } else if (getIdentifier() == null) {
            return false;
        } else if (getSessionKey() != null) {
            return true;
        }
        // TODO: check fsm running
        fsm.resume();;
        return false;
    }

    @Override
    public String getSessionKey() {
        return key;
    }

    public void setSessionKey(String sessionKey) {
        key = sessionKey;
    }

    public void start(SessionState.Delegate delegate) {
        stop();
        Thread thr = new Thread(this);
        thr.setDaemon(true);
        thr.start();
        thread = thr;

        // start state machine
        fsm.setDelegate(delegate);
        fsm.start();
    }

    @Override
    public void stop() {
        super.stop();

        // stop state machine
        fsm.stop();

        // wait for thread stop
        Thread thr = thread;
        if (thr != null) {
            // waiting 2 seconds for stopping the thread
            thread = null;
            try {
                thr.join(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void setup() {
        setActive(true, null);
        super.setup();
    }

    @Override
    public void finish() {
        setActive(false, null);
        super.finish();
    }

    @Override
    protected StreamHub createHub(Connection.Delegate delegate, SocketAddress remote, SocketChannel sock) {
        assert sock == null : "client socket error";
        assert remote != null : "remote address empty";
        StreamClientHub hub = new StreamClientHub(delegate);
        BackgroundThreads.wait(new Runnable() {
            @Override
            public void run() {
                Connection conn = hub.connect(remote, null);
                if (conn == null) {
                    SessionState state = fsm.getCurrentState();
                    Log.error("failed to connect remote: " + remote + ", state: " + state);
                    // assert false : "failed to connect remote: " + remote;
                }
                // TODO: reset send buffer size
            }
        });
        return hub;
    }

    //
    //  Docker Delegate
    //

    @Override
    public void onPorterStatusChanged(Porter.Status previous, Porter.Status current, Porter docker) {
        //super.onPorterStatusChanged(previous, current, docker);
        if (current == null || current.equals(Porter.Status.ERROR)) {
            // connection error or session finished
            // TODO: reconnect?
            setActive(false, null);
            // TODO: clear session ID and handshake again
        } else if (current.equals(Porter.Status.READY)) {
            // connected/ reconnected
            setActive(true, null);
        }
    }

    @Override
    public void onPorterReceived(Arrival ship, Porter docker) {
        //super.onPorterReceived(ship, docker);
        List<byte[]> allResponses = new ArrayList<>();
        Messenger messenger = getMessenger();
        // 1. get data packages from arrival ship's payload
        List<byte[]> packages = getDataPackages(ship);
        List<byte[]> responses;
        for (byte[] pack : packages) {
            try {
                // 2. process each data package
                responses = messenger.processPackage(pack);
                if (responses == null) {
                    continue;
                }
                for (byte[] res : responses) {
                    if (res == null || res.length == 0) {
                        // should not happen
                        continue;
                    }
                    allResponses.add(res);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        CommonGate gate = getGate();
        SocketAddress source = docker.getRemoteAddress();
        SocketAddress destination = docker.getLocalAddress();
        // 3. send responses separately
        for (byte[] res : allResponses) {
            gate.sendResponse(res, ship, source, destination);
        }
    }

    public static List<byte[]> getDataPackages(Arrival arrival) {
        StreamArrival ship = (StreamArrival) arrival;
        byte[] payload = ship.getPayload();
        // check payload
        if (payload == null || payload.length == 0) {
            return new ArrayList<>();
        } else if (payload[0] == '{') {
            // JsON in lines
            return ArrayUtils.splitLines(payload);
        } else {
            // TODO: other format?
            List<byte[]> array = new ArrayList<>();
            array.add(payload);
            return array;
        }
    }
}
