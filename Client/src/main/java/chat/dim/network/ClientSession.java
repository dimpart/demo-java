/* license: https://mit-license.org
 *
 *  DIMP : Decentralized Instant Messaging Protocol
 *
 *                                Written in 2022 by Moky <albert.moky@gmail.com>
 *
 * ==============================================================================
 * The MIT License (MIT)
 *
 * Copyright (c) 2022 Albert Moky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * ==============================================================================
 */
package chat.dim.network;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;

import chat.dim.Messenger;
import chat.dim.dbi.SessionDBI;
import chat.dim.mkm.Station;
import chat.dim.mtp.StreamArrival;
import chat.dim.net.Connection;
import chat.dim.port.Arrival;
import chat.dim.port.Docker;
import chat.dim.tcp.StreamHub;
import chat.dim.threading.BackgroundThreads;
import chat.dim.utils.ArrayUtils;
import chat.dim.utils.Log;

/**
 *  Session for Connection
 *  ~~~~~~~~~~~~~~~~~~~~~~
 *
 *  'key' - Session Key
 *          A random string generated by station.
 *          It will be set after handshake success.
 *
 *   'ID' - Local User ID
 *          It will be set before connecting to remote station.
 *          When it's empty, the session state would be 'Default'.
 *
 *   'active' - Session Status
 *          It will be set to True after connected to remote station.
 *          When connection broken, it will be set to False.
 *          Only send message when it's True.
 *
 *   'station' - Remote Station
 *          Station with remote IP & port, its ID will be set
 *          when first handshake responded, and we can trust
 *          all messages from this ID after that.
 */
public class ClientSession extends BaseSession {

    private final Station station;
    private final StateMachine fsm;

    private String key;
    private Thread thread;

    public ClientSession(Station server, SessionDBI sdb) {
        super(new InetSocketAddress(server.getHost(), server.getPort()), null, sdb);
        station = server;
        fsm = new StateMachine(this);
        key = null;
        thread = null;
    }

    public Station getStation() {
        return station;
    }

    public void pause() {
        fsm.pause();
    }

    public void resume() {
        fsm.resume();
    }

    public SessionState getState() {
        SessionState state = fsm.getCurrentState();
        return  state != null ? state : fsm.getDefaultState();
    }

    @Override
    public String getKey() {
        return key;
    }

    public void setKey(String sessionKey) {
        key = sessionKey;
    }

    public void start(SessionState.Delegate delegate) {
        stop();
        Thread thr = new Thread(this);
        thr.setDaemon(true);
        thr.start();
        thread = thr;

        // start state machine
        fsm.setDelegate(delegate);
        fsm.start();
    }

    @Override
    public void stop() {
        super.stop();

        // stop state machine
        fsm.stop();

        // wait for thread stop
        Thread thr = thread;
        if (thr != null) {
            // waiting 2 seconds for stopping the thread
            thread = null;
            try {
                thr.join(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void setup() {
        setActive(true, 0);
        super.setup();
    }

    @Override
    public void finish() {
        setActive(false, 0);
        super.finish();
    }

    @Override
    protected StreamHub createHub(Connection.Delegate delegate, SocketAddress remote, SocketChannel sock) {
        assert sock == null : "client socket error";
        assert remote != null : "remote address empty";
        StreamClientHub hub = new StreamClientHub(delegate);
        BackgroundThreads.wait(new Runnable() {
            @Override
            public void run() {
                Connection conn = hub.connect(remote, null);
                if (conn == null) {
                    SessionState state = fsm.getCurrentState();
                    Log.error("failed to connect remote: " + remote + ", state: " + state);
                    // assert false : "failed to connect remote: " + remote;
                }
                // TODO: reset send buffer size
            }
        });
        return hub;
    }

    //
    //  Docker Delegate
    //

    @Override
    public void onDockerStatusChanged(Docker.Status previous, Docker.Status current, Docker docker) {
        //super.onDockerStatusChanged(previous, current, docker);
        if (current == null || current.equals(Docker.Status.ERROR)) {
            // connection error or session finished
            // TODO: reconnect?
            setActive(false, 0);
            // TODO: clear session ID and handshake again
        } else if (current.equals(Docker.Status.READY)) {
            // connected/ reconnected
            setActive(true, 0);
        }
    }

    @Override
    public void onDockerReceived(Arrival ship, Docker docker) {
        //super.onDockerReceived(ship, docker);
        List<byte[]> allResponses = new ArrayList<>();
        Messenger messenger = getMessenger();
        // 1. get data packages from arrival ship's payload
        List<byte[]> packages = getDataPackages(ship);
        List<byte[]> responses;
        for (byte[] pack : packages) {
            try {
                // 2. process each data package
                responses = messenger.processPackage(pack);
                if (responses == null) {
                    continue;
                }
                for (byte[] res : responses) {
                    if (res == null || res.length == 0) {
                        // should not happen
                        continue;
                    }
                    allResponses.add(res);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        CommonGate gate = getGate();
        SocketAddress source = docker.getRemoteAddress();
        SocketAddress destination = docker.getLocalAddress();
        // 3. send responses separately
        for (byte[] res : allResponses) {
            gate.sendResponse(res, ship, source, destination);
        }
    }

    public static List<byte[]> getDataPackages(Arrival arrival) {
        StreamArrival ship = (StreamArrival) arrival;
        byte[] payload = ship.getPayload();
        // check payload
        if (payload == null || payload.length == 0) {
            return new ArrayList<>();
        } else if (payload[0] == '{') {
            // JsON in lines
            return ArrayUtils.splitLines(payload);
        } else {
            // TODO: other format?
            List<byte[]> array = new ArrayList<>();
            array.add(payload);
            return array;
        }
    }
}
